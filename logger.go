/*=============================================================================
#     FileName: logext.go
#       Author: sunminghong, allen.fantasy@gmail.com, http://weibo.com/5d13
#         Team: http://1201.us
#   LastChange: 2013-12-15 11:14:56
#      History:
=============================================================================*/

package freelog

import (
    "bytes"
    "fmt"
    "runtime"
    "strings"
    "sync"
    "time"
    //"strconv"
)

// These flags define which text to prefix to each log entry generated by the LoggerExt.
const (
    Ldate         = 1 << iota // the date: 2009/0123
    Ltime                     // the time: 01:23:23
    Lmicroseconds             // microsecond resolution: 01:23:23.123123.  assumes Ltime.
    Llongfile                 // full file name and line number: /a/b/c/d.go:23
    Lshortfile                // final file name element and line number: d.go:23. overrides Llongfile

    Lmodule                   // module name
    LstdFlags = Ldate | Ltime // initial values for the standard logger
    Ldefault  = Lmodule | Lshortfile | LstdFlags | Lmicroseconds
)   // [prefix][time][level][module][shortfile|longfile]

var reqId int

var levels = []string{
    "[A]",
    "[T]",
    "[D]",
    "[I]",
    "[W]",
    "[E]",
    "[P]",
    "[F]",
}

// 根据go标准库log 源码扩展的日志类型
// 修改了日志等级应用方法
// 增加了记录访问代码模块、file、function name
type LoggerExt struct {
    mu         sync.Mutex // ensures atomic writes; protects the following fields
    prefix     string     // prefix to write at beginning of each line
    flag       int        // properties
    Level      int
    out        IWriter       // destination for writer
    buf        *bytes.Buffer // for accumulating text to write
    levelStats [8]int64
}

// New creates a new LoggerExt.   The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func NewLoggerExt(out IWriter, prefix string, flag int) *LoggerExt {
    return &LoggerExt{out: out, prefix: prefix, Level: 1, flag: flag, buf: bytes.NewBufferString("")}
}

func moduleOf(file string) string {
    pos := strings.LastIndex(file, "/")
    if pos != -1 {
        pos1 := strings.LastIndex(file[:pos], "/src/")
        if pos1 != -1 {
            return file[pos1+5 : pos]
        }
    }
    return "UNKNOWN"
}

// Cheap integer to fixed-width decimal ASCII.  Give a negative width to avoid zero-padding.
// Knows the buffer has capacity.
func itoa(buf *bytes.Buffer, i int, wid int) {
    var u uint = uint(i)
    if u == 0 && wid <= 1 {
        buf.WriteByte('0')
        return
    }

    // Assemble decimal in reverse order.
    var b [32]byte
    bp := len(b)
    for ; u > 0 || wid > 0; u /= 10 {
        bp--
        wid--
        b[bp] = byte(u%10) + '0'
    }

    // avoid slicing b to avoid an allocation.
    for bp < len(b) {
        buf.WriteByte(b[bp])
        bp++
    }
}

func (l *LoggerExt) formatHeader(t *time.Time, lvl int, reqId string) {
    buf := l.buf
    if l.prefix != "" {
        buf.WriteString(l.prefix)
    }
    if reqId != "" {
        //buf.WriteByte('[')
        buf.WriteString(reqId)
        //buf.WriteByte(']')
        buf.WriteByte(' ')
    }
    if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
        if l.flag&Ldate != 0 {
            year, month, day := t.Date()
            itoa(buf, year - 2000, 2)
            buf.WriteByte('/')
            itoa(buf, int(month), 2)
            buf.WriteByte('/')
            itoa(buf, day, 2)
            buf.WriteByte(' ')
        }
        if l.flag&(Ltime|Lmicroseconds) != 0 {
            hour, min, sec := t.Clock()
            itoa(buf, hour, 2)
            buf.WriteByte(':')
            itoa(buf, min, 2)
            buf.WriteByte(':')
            itoa(buf, sec, 2)
            if l.flag&Lmicroseconds != 0 {
                buf.WriteByte('.')
                itoa(buf, t.Nanosecond()/1e3, 6)
            }
            buf.WriteByte(' ')
        }
    }
    buf.WriteString(levels[lvl] + " ")
}

// Output writes the writer for a logging event.  The string s contains
// the text to print after the prefix specified by the flags of the
// LoggerExt.  A newline is appended if the last character of s is not
// already a newline.  Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
func (l *LoggerExt) Output(lvl int, calldepth int, s string) {
    now := time.Now() // get this early.
    l.mu.Lock()
    defer l.mu.Unlock()
    reqId++
    sreqId := fmt.Sprintf("#FL%07d#", reqId)
    l.levelStats[lvl]++
    l.buf.Reset()
    l.formatHeader(&now, lvl, sreqId)

    var n int
    if lvl == levelWarn {
        n = 1
    } else if lvl > levelWarn {
        n = 3
    }

    if n > 0 && (l.flag&(Lshortfile|Llongfile|Lmodule) != 0) {
        buf := l.buf
        buf.WriteByte('\n')

        // release lock while getting caller info - it's expensive.
        l.mu.Unlock()
        for i := calldepth; i < calldepth + n; i++ {
            var ok bool
            pc, file, line, ok := runtime.Caller(i)
            if ok {
                funname := runtime.FuncForPC(pc).Name()

                buf.WriteString("    ")
                if l.flag&Lmodule != 0 {
                    buf.WriteByte('[')
                    //buf.WriteString(moduleOf(file))
                    buf.WriteString(funname)
                    buf.WriteString("()] ")
                }
                if l.flag&(Lshortfile|Llongfile) != 0 {
                    if l.flag&Lshortfile != 0 {
                        short := file
                        for i := len(file) - 1; i > 0; i-- {
                            if file[i] == '/' {
                                short = file[i+1:]
                                break
                            }
                        }
                        file = short
                    }
                    buf.WriteString(file)
                    buf.WriteByte(':')
                    itoa(buf, line, -1)
                    buf.WriteString("\n")
                }
            }
        }
        l.mu.Lock()
    }

    l.buf.WriteString(s)
    //fmt.Printf("% X",[]byte(s))
    if len(s) > 0 && s[len(s)-1] != '\n' {
        l.buf.WriteByte('\n')
    }
    l.out.WriteLog(&now, lvl, l.buf.Bytes())
    return
}

func (l *LoggerExt) Stat() (stats []int64) {
    l.mu.Lock()
    v := l.levelStats
    l.mu.Unlock()
    return v[:]
}

// Flags returns the writer flags for the logger.
func (l *LoggerExt) Flags() int {
    l.mu.Lock()
    defer l.mu.Unlock()
    return l.flag
}

// SetFlags sets the writer flags for the logger.
func (l *LoggerExt) SetFlags(flag int) {
    l.mu.Lock()
    defer l.mu.Unlock()
    l.flag = flag
}

// Prefix returns the writer prefix for the logger.
func (l *LoggerExt) Prefix() string {
    l.mu.Lock()
    defer l.mu.Unlock()
    return l.prefix
}

// SetPrefix sets the writer prefix for the logger.
func (l *LoggerExt) SetPrefix(prefix string) {
    l.mu.Lock()
    defer l.mu.Unlock()
    l.prefix = prefix
}

// SetOutputLevel sets the writer level for the logger.
func (l *LoggerExt) SetOutputLevel(lvl int) {
    l.mu.Lock()
    defer l.mu.Unlock()
    l.Level = lvl
}

/*
// -----------------------------------------

// Printf calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Printf.
func (l *LoggerExt) Printf(format string, v ...interface{}) {
	l.Output(levelInfo, 2, fmt.Sprintf(format, v...))
}

// Print calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Print.
func (l *LoggerExt) Print(v ...interface{}) {
    l.Output(levelInfo, 2, fmt.Sprint(v...))
}

// Println calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Println.
func (l *LoggerExt) Println(v ...interface{}) {
    l.Output(levelInfo, 2, fmt.Sprintln(v...))
}

// -----------------------------------------

func (l *LoggerExt) Debugf(format string, v ...interface{}) {
	l.Output(levelDebug, 2, fmt.Sprintf(format, v...))
}

func (l *LoggerExt) Debug(v ...interface{}) {
	l.Output(levelDebug, 2, fmt.Sprintln(v...))
}

// -----------------------------------------

func (l *LoggerExt) Infof(format string, v ...interface{}) {
	l.Output(levelInfo, 2, fmt.Sprintf(format, v...))
}

func (l *LoggerExt) Info(v ...interface{}) {
	l.Output(levelInfo, 2, fmt.Sprintln(v...))
}

// -----------------------------------------

func (l *LoggerExt) Warnf(format string, v ...interface{}) {
	l.Output(levelWarn, 2, fmt.Sprintf(format, v...))
}

func (l *LoggerExt) Warn(v ...interface{}) {
    l.Output(levelWarn, 2, fmt.Sprintln(v...))
}

// -----------------------------------------

func (l *LoggerExt) Errorf(format string, v ...interface{}) {
	l.Output(levelError, 2, fmt.Sprintf(format, v...))
}

func (l *LoggerExt) Error(v ...interface{}) {
    l.Output(levelError, 2, fmt.Sprintln(v...))
}

// -----------------------------------------

func (l *LoggerExt) Fatal(v ...interface{}) {
	l.Output(levelFatal, 2, fmt.Sprint(v...))
	os.Exit(1)
}

// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
func (l *LoggerExt) Fatalf(format string, v ...interface{}) {
	l.Output(levelFatal, 2, fmt.Sprintf(format, v...))
	os.Exit(1)
}

// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
func (l *LoggerExt) Fatalln(v ...interface{}) {
	l.Output(levelFatal, 2, fmt.Sprintln(v...))
	os.Exit(1)
}

// -----------------------------------------

// Panic is equivalent to l.Print() followed by a call to panic().
func (l *LoggerExt) Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	l.Output(levelPanic, 2, s)
	panic(s)
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
func (l *LoggerExt) Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	l.Output(levelPanic, 2, s)
	panic(s)
}

// Panicln is equivalent to l.Println() followed by a call to panic().
func (l *LoggerExt) Panicln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	l.Output(levelPanic, 2, s)
	panic(s)
}
*/

// -----------------------------------------
